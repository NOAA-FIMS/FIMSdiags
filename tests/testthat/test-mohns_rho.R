# Instructions ----
#' This file follows the format generated by FIMS:::use_testthat_template().
#' Necessary tests include input and output (IO) correctness [IO
#' correctness], edge-case handling [Edge handling], and built-in errors and
#' warnings [Error handling]. See `?FIMS:::use_testthat_template` for more
#' information. Every test should have a @description tag, which can span
#' multiple lines, that will be used in the bookdown report of the results from
#' {testthat}.

# calculate_mohns_rho ----
## Setup ----
# Load or prepare any necessary data for testing
# clear memory
clear()
## Load sample data
data("data1")
# Prepare data for FIMS model
data_4_model <- FIMSFrame(data1)
# Create parameters
parameters <- data_4_model |>
  create_default_configurations() |>
  create_default_parameters(data = data_4_model)

# Run retrospective analysis for testing
retro_fit <- run_fims_retrospective(
  years_to_remove = 0:2, 
  data = data1, 
  parameters = parameters, 
  n_cores = 1
)

## IO correctness ----
test_that("calculate_mohns_rho() works with correct inputs", {
  #' @description Test that calculate_mohns_rho() returns a numeric value.
  
  rho_ssb <- calculate_mohns_rho(retro_fit, quantity = "spawning_biomass")
  
  expect_equal(
    object = class(rho_ssb),
    expected = "numeric"
  )
  
  expect_equal(
    object = length(rho_ssb),
    expected = 1
  )
  
  #' @description Test that calculate_mohns_rho() returns expected value for spawning biomass.
  # Based on the retrospective test data, calculate expected rho manually
  # Using values from test-fims_retrospective.R where at year 31:
  # retro_year 0: 1803.273, retro_year 1: 2315.029, retro_year 2: 3115.032
  # For peel 1 (year 32): compare retro_year 1 at year 32 vs retro_year 0 at year 32
  # For peel 2 (year 31): compare retro_year 2 at year 31 vs retro_year 0 at year 31
  # The calculation should be: mean((peel - base) / base) for each peel
  
  expect_true(
    object = is.finite(rho_ssb) && !is.na(rho_ssb)
  )
  
  #' @description Test that calculate_mohns_rho() works with recruitment quantity.
  rho_rec <- calculate_mohns_rho(retro_fit, quantity = "recruitment")
  
  expect_equal(
    object = class(rho_rec),
    expected = "numeric"
  )
  
  expect_true(
    object = is.finite(rho_rec) && !is.na(rho_rec)
  )
})

## Edge handling ----
test_that("calculate_mohns_rho() handles edge cases correctly", {
  #' @description Test that calculate_mohns_rho() works with single peel (years_to_remove = 0:1).
  retro_fit_single <- run_fims_retrospective(
    years_to_remove = 0:1,
    data = data1,
    parameters = parameters,
    n_cores = 1
  )
  
  rho_single <- calculate_mohns_rho(retro_fit_single, quantity = "spawning_biomass")
  
  expect_equal(
    object = class(rho_single),
    expected = "numeric"
  )
  
  expect_equal(
    object = length(rho_single),
    expected = 1
  )
  
  #' @description Test that calculate_mohns_rho() returns consistent results across runs.
  rho_ssb_1 <- calculate_mohns_rho(retro_fit, quantity = "spawning_biomass")
  rho_ssb_2 <- calculate_mohns_rho(retro_fit, quantity = "spawning_biomass")
  
  expect_equal(
    object = rho_ssb_1,
    expected = rho_ssb_2
  )
})

## Error handling ----
test_that("calculate_mohns_rho() returns correct error messages", {
  #' @description Test that calculate_mohns_rho() errors with invalid retro_fit (not a list).
  expect_error(
    object = calculate_mohns_rho(
      retro_fit = "not_a_list",
      quantity = "spawning_biomass"
    ),
    regexp = "must be a list"
  )
  
  #' @description Test that calculate_mohns_rho() errors with missing elements in retro_fit.
  expect_error(
    object = calculate_mohns_rho(
      retro_fit = list(years_to_remove = 0:2),
      quantity = "spawning_biomass"
    ),
    regexp = "must contain 'years_to_remove' and 'estimates' elements"
  )
  
  #' @description Test that calculate_mohns_rho() errors with invalid quantity (not character).
  expect_error(
    object = calculate_mohns_rho(
      retro_fit = retro_fit,
      quantity = 123
    ),
    regexp = "must be a single character string"
  )
  
  #' @description Test that calculate_mohns_rho() errors with multiple quantities.
  expect_error(
    object = calculate_mohns_rho(
      retro_fit = retro_fit,
      quantity = c("spawning_biomass", "recruitment")
    ),
    regexp = "must be a single character string"
  )
  
  #' @description Test that calculate_mohns_rho() errors with invalid ref_year (not numeric).
  expect_error(
    object = calculate_mohns_rho(
      retro_fit = retro_fit,
      quantity = "spawning_biomass",
      ref_year = "not_numeric"
    ),
    regexp = "must be a single numeric value or NULL"
  )
  
  #' @description Test that calculate_mohns_rho() errors when first model is not reference (retro_year != 0).
  retro_fit_invalid <- retro_fit
  retro_fit_invalid$years_to_remove <- c(1, 2, 3)
  
  expect_error(
    object = calculate_mohns_rho(
      retro_fit = retro_fit_invalid,
      quantity = "spawning_biomass"
    ),
    regexp = "must contain reference year run"
  )
  
  #' @description Test that calculate_mohns_rho() errors with non-existent quantity.
  expect_error(
    object = calculate_mohns_rho(
      retro_fit = retro_fit,
      quantity = "non_existent_quantity"
    ),
    regexp = "not found in estimates data"
  )
})

## Warning handling ----
test_that("calculate_mohns_rho() handles warnings appropriately", {
  #' @description Test that calculate_mohns_rho() handles missing values gracefully.
  # Create a modified retro_fit with a missing value
  retro_fit_na <- retro_fit
  retro_fit_na$estimates$estimated[1] <- NA
  
  # Depending on where the NA is, this might produce a warning or still work
  # The function should handle this gracefully
  result <- tryCatch(
    {
      calculate_mohns_rho(retro_fit_na, quantity = "spawning_biomass")
    },
    warning = function(w) {
      # Check that warning message is appropriate
      expect_true(grepl("NA value|Missing value", w$message, ignore.case = TRUE))
      return(NULL)
    },
    error = function(e) {
      # If it errors, make sure it's an appropriate error
      expect_true(grepl("No valid|NA value|Missing value", e$message, ignore.case = TRUE))
      return(NULL)
    }
  )
})
